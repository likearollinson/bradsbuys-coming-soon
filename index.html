<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NicoTEEN Dreams</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400..900;1,400..900&family=Roboto:wght@400;700&display=swap');
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Roboto', sans-serif;
        }
        #intro-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            color: white;
            transition: opacity 1s ease-out;
        }
        #intro-screen h1 {
            font-family: 'Playfair Display', serif;
            font-size: 5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.7);
        }
        #intro-screen h2 {
            font-family: 'Playfair Display', serif;
            font-style: italic;
            font-size: 3rem;
            margin-top: 0;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.7);
        }
        #intro-screen p {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            text-shadow: 1px 1px 4px rgba(0,0,0,0.7);
        }
        #start-button {
            padding: 1rem 2rem;
            font-size: 1.5rem;
            color: #000;
            background-color: #fff;
            border: 2px solid #000;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        #start-button:hover {
            background-color: #000;
            color: #fff;
            border-color: #fff;
        }
        #game-canvas {
            display: block;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000000;
            z-index: 10;
        }
        #message-box {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 20px;
            text-align: center;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Intro screen with cover art -->
    <div id="intro-screen" style="background-image: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.5)), url('https://storage.googleapis.com/gemini-prod-us-west1-assets/e69c3a3344692e85_4F01559D-4F72-48DD-B7BD-CD982912C63A.jpeg');">
        <h1>NicoTEEN dreams</h1>
        <h2>ConYe</h2>
        <p>by Brad</p>
        <button id="start-button">Start Game</button>
    </div>

    <!-- Heads-Up Display -->
    <div id="hud">
        <div id="score">Score: 0</div>
        <div id="time">Time: 120</div>
    </div>

    <!-- In-game messages -->
    <div id="message-box">New Objective!</div>

    <!-- Game canvas -->
    <canvas id="game-canvas"></canvas>

    <!-- Soundtrack -->
    <audio id="soundtrack" loop>
        <source src="https://storage.googleapis.com/gemini-prod-us-west1-assets/e69c3a3344692e85_Triangle_Springs_3.mp4" type="video/mp4">
        Your browser does not support the audio element.
    </audio>

    <script type="module">
        // --- Game Setup ---
        const introScreen = document.getElementById('intro-screen');
        const startButton = document.getElementById('start-button');
        const soundtrack = document.getElementById('soundtrack');
        const scoreEl = document.getElementById('score');
        const timeEl = document.getElementById('time');
        const messageBox = document.getElementById('message-box');

        let scene, camera, renderer, world;
        let player = {
            mesh: null,
            body: null,
            direction: new THREE.Vector3(),
            speed: 25,
            isGrounded: false
        };
        const keys = {};
        const gameObjects = []; // To hold meshes and bodies for cleanup
        let score = 0;
        let time = 120;
        let timerInterval;

        // --- Event Listeners ---
        startButton.addEventListener('click', () => {
            introScreen.style.opacity = '0';
            setTimeout(() => {
                introScreen.style.display = 'none';
                init();
            }, 1000);

            // Audio can only start after user interaction
            soundtrack.play().catch(error => console.error("Audio playback failed:", error));
        });

        window.addEventListener('keydown', (e) => keys[e.code] = true);
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        // --- Initialization ---
        function init() {
            // Physics World
            world = new CANNON.World();
            world.gravity.set(0, -50, 0); // Stronger gravity
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.allowSleep = true;

            // Scene and Camera
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.007);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 30);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);


            // Create the world
            createGround();
            createCity();
            createPlayer();
            spawnObjective();

            // Start timer
            timerInterval = setInterval(() => {
                time--;
                timeEl.textContent = `Time: ${time}`;
                if (time <= 0) {
                    clearInterval(timerInterval);
                    showMessage("Game Over!");
                }
            }, 1000);

            // Start game loop
            animate();
        }

        // --- World Creation ---
        function createGround() {
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);

            const groundGeometry = new THREE.PlaneGeometry(500, 500);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, side: THREE.DoubleSide });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
        }

        function createCity() {
            // Create various ramps and blocks for a skatepark feel
            createBox(10, 20, 30, { x: 40, y: 10, z: 0 });
            createBox(10, 10, 10, { x: -30, y: 5, z: 20 });
            createRamp(20, 10, 20, { x: 0, y: 0, z: -50 }, {y: 0});
            createRamp(20, 15, 30, { x: -80, y: 0, z: 0 }, {y: Math.PI / 2});
            createRamp(20, 15, 30, { x: 80, y: 0, z: 0 }, {y: -Math.PI / 2});

            // Some buildings
            for (let i = 0; i < 15; i++) {
                const sizeX = Math.random() * 20 + 10;
                const sizeZ = Math.random() * 20 + 10;
                const height = Math.random() * 50 + 20;
                const posX = (Math.random() - 0.5) * 400;
                const posZ = (Math.random() - 0.5) * 400;
                // Ensure buildings aren't in the central play area
                if (Math.abs(posX) > 50 || Math.abs(posZ) > 50) {
                    createBox(sizeX, height, sizeZ, { x: posX, y: height / 2, z: posZ });
                }
            }
        }

        // --- Player Creation ---
        function createPlayer() {
            // Player character named "ConYe"
            const playerShape = new CANNON.Sphere(1.5);
            player.body = new CANNON.Body({
                mass: 70,
                position: new CANNON.Vec3(0, 10, 0),
                shape: playerShape,
                linearDamping: 0.5 // Simulates friction/air resistance
            });
            world.addBody(player.body);

            const playerGeometry = new THREE.CapsuleGeometry(1, 2, 4, 8);
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
            player.mesh = new THREE.Mesh(playerGeometry, playerMaterial);
            player.mesh.castShadow = true;
            scene.add(player.mesh);
            
            // Listen for collisions to detect if grounded
            player.body.addEventListener("collide", (event) => {
                 // Check if the collision normal is mostly pointing up.
                if(event.contact.ni.y > 0.5){
                    player.isGrounded = true;
                }
            });
        }
        
        // --- Objective System (Crazy Taxi style) ---
        let currentObjective = null;

        function spawnObjective() {
            if (currentObjective) {
                scene.remove(currentObjective.mesh);
            }

            const posX = (Math.random() - 0.5) * 150;
            const posZ = (Math.random() - 0.5) * 150;

            const objectiveGeometry = new THREE.CylinderGeometry(5, 5, 20, 32);
            const objectiveMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.6 });
            const objectiveMesh = new THREE.Mesh(objectiveGeometry, objectiveMaterial);
            objectiveMesh.position.set(posX, 10, posZ);

            currentObjective = {
                mesh: objectiveMesh,
                position: new THREE.Vector3(posX, 10, posZ),
                radius: 5
            };
            scene.add(objectiveMesh);
            showMessage("New Objective!");
        }


        // --- Helper functions for creating objects ---
        function createBox(width, height, depth, position, rotation = {x:0, y:0, z:0}) {
            const shape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));
            const body = new CANNON.Body({ mass: 0 });
            body.addShape(shape);
            body.position.set(position.x, position.y, position.z);
            body.quaternion.setFromEuler(rotation.x, rotation.y, rotation.z);
            world.addBody(body);

            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(body.position);
            mesh.quaternion.copy(body.quaternion);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            gameObjects.push({mesh, body});
        }
        
        function createRamp(width, height, depth, position, rotation) {
            const shape = new CANNON.Box(new CANNON.Vec3(width / 2, height / 2, depth / 2));
            const body = new CANNON.Body({ mass: 0 });
            // For ramps, we rotate the physics body
            const angle = Math.atan2(height, depth);
            body.addShape(shape, new CANNON.Vec3(), new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(1,0,0), angle));
            body.position.set(position.x, position.y + height/2, position.z);
            body.quaternion.setFromEuler(0, rotation.y, 0);
            world.addBody(body);

            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ color: 0x8888ff });
            const mesh = new THREE.Mesh(geometry, material);
            // We rotate the visual mesh differently to create the ramp shape
            mesh.position.copy(body.position);
            mesh.quaternion.copy(body.quaternion);
            mesh.rotation.x += angle;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            gameObjects.push({mesh, body});
        }

        // --- Game Logic and Controls ---
        function updatePlayer() {
            if (!player.body) return;
            
            player.isGrounded = false; // Assume not grounded until a collision proves otherwise

            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            const right = new THREE.Vector3().crossVectors(camera.up, forward).normalize();

            const force = new CANNON.Vec3(0, 0, 0);
            const moveSpeed = player.speed;

            if (keys['ArrowUp'] || keys['KeyW']) {
                force.x += forward.x * moveSpeed;
                force.z += forward.z * moveSpeed;
            }
            if (keys['ArrowDown'] || keys['KeyS']) {
                force.x -= forward.x * moveSpeed;
                force.z -= forward.z * moveSpeed;
            }
            if (keys['ArrowLeft'] || keys['KeyA']) {
                force.x += right.x * moveSpeed;
                force.z += right.z * moveSpeed;
            }
            if (keys['ArrowRight'] || keys['KeyD']) {
                force.x -= right.x * moveSpeed;
                force.z -= right.z * moveSpeed;
            }
            
            player.body.applyForce(force, player.body.position);
            
            // Ollie (Jump)
            if (keys['Space'] && player.isGrounded) {
                player.body.velocity.y = 25; // Apply an upward impulse
            }
        }
        
        function checkObjectiveCollision() {
            if (!player.body || !currentObjective) return;
            const playerPos = player.body.position;
            const objectivePos = currentObjective.position;
            const distance = playerPos.distanceTo(objectivePos);

            if (distance < currentObjective.radius) {
                score += 100;
                time += 15;
                scoreEl.textContent = `Score: ${score}`;
                timeEl.textContent = `Time: ${time}`;
                spawnObjective();
            }
        }
        
        function showMessage(text) {
            messageBox.textContent = text;
            messageBox.style.opacity = '1';
            setTimeout(() => {
                messageBox.style.opacity = '0';
            }, 2000);
        }

        // --- Game Loop ---
        function animate() {
            if (time <= 0) return; // Stop the loop when game is over
            requestAnimationFrame(animate);

            // Update physics
            world.step(1 / 60);

            // Update player logic
            updatePlayer();
            checkObjectiveCollision();

            // Sync visual objects with physics bodies
            if (player.mesh && player.body) {
                player.mesh.position.copy(player.body.position);
                player.mesh.quaternion.copy(player.body.quaternion);
            }
            
            // Update camera to follow player
            const cameraOffset = new THREE.Vector3(0, 8, 15);
            const playerPosition = new THREE.Vector3().copy(player.body.position);
            const cameraPosition = playerPosition.clone().add(cameraOffset);
            camera.position.lerp(cameraPosition, 0.1);
            camera.lookAt(playerPosition);
            
            // Animate objective
            if (currentObjective) {
                currentObjective.mesh.rotation.y += 0.01;
            }

            renderer.render(scene, camera);
        }
        
        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
